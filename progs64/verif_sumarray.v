(* Do not edit this file, it was generated automatically *)
Require Import VST.floyd.proofauto. (* Import the Verifiable C system *)
Require Import VST.progs64.sumarray. (* Import the AST of this C program *)
(* The next line is "boilerplate", always required after importing an AST. *)
#[export] Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs.  mk_varspecs prog. Defined.

(* Functional spec of this program.  *)
Definition sum_Z : list Z -> Z := fold_right Z.add 0.

Lemma sum_Z_app:
  forall a b, sum_Z (a++b) =  sum_Z a + sum_Z b.
Proof.
  intros. induction a; simpl; lia.
Qed.

Section Spec.

Context  `{!default_VSTGS Σ}.

Definition sumarray_spec : ident * funspec :=
 DECLARE _sumarray
  WITH a: val, sh : share, contents : list Z, size: Z
  PRE [ (tptr tuint), tint ]
          PROP  (readable_share sh; 0 <= size <= Int.max_signed;
                 Forall (fun x => 0 <= x <= Int.max_unsigned) contents)
          PARAMS (a; Vint (Int.repr size))
          GLOBALS ()
          SEP   (data_at sh (tarray tuint size) (map Vint (map Int.repr contents)) a)
  POST [ tuint ]
        PROP () LOCAL(temp ret_temp  (Vint (Int.repr (sum_Z contents))))
           SEP (data_at sh (tarray tuint size) (map Vint (map Int.repr contents)) a).

(* Note: It would also be reasonable to let [contents] have type [list int].
  Then the [Forall] would not be needed in the PROP part of PRE.
*)

(* The precondition of "int main(void){}" always looks like this. *)
Definition main_spec :=
 DECLARE _main
  WITH gv : globals
  PRE  [] main_pre prog tt gv
  POST [ tint ]  
     PROP() 
     LOCAL (temp ret_temp (Vint (Int.repr (1+2+3+4)))) 
     SEP(True).

(* Note: It would also be reasonable to let [contents] have type [list int].
  Then the [Forall] would not be needed in the PROP part of PRE.
*)

(* Packaging the API spec all together. *)
Definition Gprog : funspecs :=
        ltac:(with_library prog [sumarray_spec; main_spec]).

(** Proof that f_sumarray, the body of the sumarray() function,
 ** satisfies sumarray_spec, in the global context (Vprog,Gprog).
 **)
Lemma body_sumarray: semax_body Vprog Gprog ⊤ f_sumarray sumarray_spec.
Proof.
start_function. (* Always do this at the beginning of a semax_body proof *)
(* The next two lines do forward symbolic execution through
   the first two executable statements of the function body *)
forward.  (* i = 0; *)
forward.  (* s = 0; *)
(* To do symbolic execution through a [while] loop, we must
 * provide a loop invariant, so we use [forward_while] with
 * the invariant as an argument .*)
forward_while
 (∃ i: Z,
   PROP  (0 <= i <= size)
   LOCAL (temp _a a;
          temp _i (Vint (Int.repr i));
          temp _n (Vint (Int.repr size));
          temp _s (Vint (Int.repr (sum_Z (sublist 0 i contents)))))
   SEP   (data_at sh (tarray tuint size) (map Vint (map Int.repr contents)) a)).
(* forward_while leaves four subgoals; here we label them
   with the * bullet. *)
* (* Prove that current precondition implies loop invariant *)
Exists 0.   (* Instantiate the existential on the right-side of |--   *)
entailer!.  (* Simplify this entailment as much as possible; in this
      case, it solves entirely; in other cases, entailer! leaves subgoals *)
* (* Prove that loop invariant implies typechecking condition *)
entailer!.  (* Typechecking conditions usually solve quite easily *)
* (* Prove postcondition of loop body implies loop invariant *)
(* In order to get to the postcondition of the loop body, of course,
   we must forward-symbolic-execute through the loop body;
   so we start that here. *)
(* "forward" fails and tells us to first make (0 <= i < Zlength contents)
   provable by auto, so we assert the following: *)
assert_PROP (Zlength contents = size). {
  entailer!. do 2 rewrite Zlength_map. reflexivity.
}
forward. (* x = a[i] *)
forward. (* s += x; *) 
forward. (* i++; *) 
 (* Now we have reached the end of the loop body, and it's
   time to prove that the _current precondition_  (which is the
   postcondition of the loop body) entails the loop invariant. *)
 Exists (i+1).  simpl.
 entailer!. simpl.
 f_equal.
 rewrite ->(sublist_split 0 i (i+1)) by lia.
 rewrite sum_Z_app. rewrite ->(sublist_one i) by lia.
 autorewrite with sublist. normalize.
 simpl. rewrite Z.add_0_r. reflexivity.
* (* After the loop *)
forward.  (* return s; *)
 (* Here we prove that the postcondition of the function body
    entails the postcondition demanded by the function specification. *)
entailer!.
autorewrite with sublist in *.
autorewrite with sublist.
reflexivity.
Qed.

(* Contents of the extern global initialized array "_four" *)
Definition four_contents := [1; 2; 3; 4].

Lemma body_main:  semax_body Vprog Gprog ⊤ f_main main_spec.
Proof.
start_function1.
start_function2.

(* forward.v: start_function3 *)
simpl app;
 simplify_func_tycontext;
 repeat match goal with
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end.


 (* forward.v: start_function3: try expand_main_pre. *)
 match goal with | |- semax _ _ (main_pre_old ?prog _ _ ∗ _) _ _ =>
 rewrite main_pre_start_old;
 unfold prog_vars, prog
                       | |- semax _ _ (main_pre_old ?prog _ _) _ _ =>
 rewrite main_pre_start_old;
 unfold prog_vars, prog
end.
rewrite prog_defs_Clight_mkprogram;
simpl globvars2pred.
simple eapply semax_process_globvars.
-
(* global_lemmas.v: expand_main_pre_old: process_globals. *)
(* global_lemmas.v: repeat process_idstar. *)
process_one_globvar.
     lazymatch goal with Delta := @abbreviate tycontext _ 
                             |- ENTAIL _, globvars_in_process _ _ ?A _ ⊢ _ =>  idtac "AHH" end.
                             

      match A with id2pred_star _ _ _ (_ ?i) _ =>
         let p := fresh "p" in set (p:=A);
         simpl in p;
         unfold id2pred_star, init_data2pred' in p;
         simpl PTree.get in p; simpl zeq in p;
         cbv beta iota zeta in p;
         simpl init_data_size in p;
         revert p; rewrite ?offset_offset_val; intro p; simpl Z.add in p;
         let t := constr:(match (glob_types Delta) !! i with Some x => x | _ => Tvoid end) in
         let t := eval hnf in t in
         match t with Tpointer ?t2 _ =>
           repeat match goal with p := ?D |- _ =>
                       match D with context [mapsto ?sh ?t' ?q ?v] =>
                            revert p;
                           change (mapsto sh t' q v) with (mapsto sh size_t q nullval);
                           rewrite <- (mapsto_tuint_tptr_nullval sh q t2);
                           intro p
                       end end
         | _ => idtac end;
         try change (mapsto ?sh _ (?gv i) ?v) with (mapsto sh t (gv i) v) in p;
         subst p;
         repeat simple apply move_globfield_into_done
      | _ => idtac
       end
    | |- ENTAIL _, _ ⊢ _ => idtac
    end.

change (Share.lub extern_retainer _) with Ews;
change (Share.lub extern_retainer _) with Ers.
try change (Basics.compose Vint _) with (Basics.compose Vint id);
fold_types;
rewrite ?Combinators.compose_id_right;
apply ENTAIL_refl.
- simple apply finish_process_globvars.
rewrite ?offset_val_unsigned_repr;
simpl readonly2share;
autorewrite with zero_val.






 process_stackframe_of.
 repeat change_mapsto_gvar_to_data_at;  (* should really restrict this to only in main,
                                  but it needs to come after process_stackframe_of *)
 repeat rewrite <- data_at__offset_zero.
 try simple apply start_function_aux1.
 repeat (apply semax_extract_PROP;
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH
                 | Share.t => intros ?SH
                 | _ => intro
                 end
               | |- _ => intro
               end);
 abbreviate_semax;
 lazymatch goal with 
 | |- semax _ ?Delta (PROPx _ (LOCALx ?L _)) _ _ => check_parameter_vals Delta L
 | _ => idtac
 end;
 try match goal with DS := @abbreviate (PTree.t funspec) ?DS1 |- _ =>
     unify DS1 (PTree.empty funspec); clearbody DS
 end;
 start_function_hint.


(* forward_call. (*  s = sumarray(four,4); *)
  (gv _four, Ews,four_contents,4). *)
fwd_call_dep funspec_sub_refl (gv _four, Ews,four_contents,4).



 repeat constructor; computable.
forward. (* return s; *)
Qed.

#[export] Existing Instance NullExtension.Espec.

Lemma prog_correct:
  semax_prog prog tt Vprog Gprog.
Proof.
  prove_semax_prog.
  semax_func_cons body_sumarray.
  semax_func_cons body_main.
Qed.
