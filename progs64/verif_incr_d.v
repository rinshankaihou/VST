(* Do not edit this file, it was generated automatically *)
Require Import VST.concurrency.conclib.
Require Import VST.concurrency.lock_specs.
Require Import VST.atomics.SC_atomics.
Require Import VST.atomics.verif_lock.
Require Import VST.progs64.incr.

From diaframe Require Import defs.
From diaframe Require Import proofmode_base tactics.
From VST.vstep Require Import vstep vst_hints.

Import LiftNotation.

Unset Universe Polymorphism.

Set Nested Proofs Allowed.


Global Instance func_ptr_affine `{!VSTGS unit Î£} phi v : Affine $ func_ptr phi v.
Proof. by rewrite /Affine func_ptr_emp. Qed.

Lemma semax_extract_affine_sep `{!VSTGS unit Î£} {espec} {cs}:
  forall E Delta P Q R RR c Post,
        Affine RR ->
        @semax _ _ _ espec cs E Delta (PROPx P $ LOCALx Q $ SEPx R) c Post ->
        @semax _ _ _ espec cs E Delta (PROPx P $ LOCALx Q $ SEPx (RR::R)) c Post.
Proof.
  intros.
  eapply semax_pre_simple, H0.
  go_lowerx.
  iIntros "(_ & $)".
Qed.


#[export] Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs. mk_varspecs prog. Defined.

Section mpred.

(* box up concurrentGS? *)
Context `{!VSTGS unit Î£, !cinvG Î£, !inG Î£ (excl_authR natO), !atomic_int_impl (Tstruct _atom_int noattr)}.
#[local] Instance concurrent_ext_spec : ext_spec unit := concurrent_ext_spec _ (ext_link_prog prog).

Definition spawn_spec := DECLARE _spawn spawn_spec.

Definition t_counter := Tstruct _counter noattr.

Definition ghost_auth (g : gname) (n : nat) : mpred := own g (â—E n : excl_authR natO).
Definition ghost_frag (g : gname) (n : nat) : mpred := own g (â—¯E n : excl_authR natO).

Definition cptr_lock_inv (g1 g2 : gname) (ctr : val) := âˆƒ z : nat, field_at Ews t_counter [StructField _ctr] (Vint (Int.repr z)) ctr âˆ—
  âˆƒ x : nat, âˆƒ y : nat, âŒœ(z = x + y)%natâŒ âˆ§ ghost_auth g1 x âˆ— ghost_auth g2 y.

Definition incr_spec :=
 DECLARE _incr
  WITH sh1 : share, sh : Qp, h : lock_handle, g1 : gname, g2 : gname, left : bool, n : nat, gv: globals
  PRE [ ]
         PROP  (readable_share sh1)
         PARAMS () GLOBALS (gv)
         SEP   (field_at sh1 t_counter [StructField _lock] (ptr_of h) (gv _c); lock_inv sh h (cptr_lock_inv g1 g2 (gv _c)); ghost_frag (if left then g1 else g2) n)
  POST [ tvoid ]
         PROP ()
         LOCAL ()
         SEP (field_at sh1 t_counter [StructField _lock] (ptr_of h) (gv _c); lock_inv sh h (cptr_lock_inv g1 g2 (gv _c)); ghost_frag (if left then g1 else g2) (n+1)%nat).

Definition read_spec :=
 DECLARE _read
  WITH sh1 : share, sh : Qp, h : lock_handle, g1 : gname, g2 : gname, n1 : nat, n2 : nat, gv: globals
  PRE [ ]
         PROP  (readable_share sh1)
         PARAMS () GLOBALS (gv)
         SEP   (field_at sh1 t_counter [StructField _lock] (ptr_of h) (gv _c); lock_inv sh h (cptr_lock_inv g1 g2 (gv _c)); ghost_frag g1 n1; ghost_frag g2 n2)
  POST [ tuint ]
         PROP ()
         RETURN (Vint (Int.repr (n1 + n2)%nat))
         SEP (field_at sh1 t_counter [StructField _lock] (ptr_of h) (gv _c); lock_inv sh h (cptr_lock_inv g1 g2 (gv _c)); ghost_frag g1 n1; ghost_frag g2 n2).

Definition thread_lock_R sh1 (sh : Qp) h (g1 g2 : gname) (ctr : val) (left : bool) :=
  field_at sh1 t_counter [StructField _lock] (ptr_of h) ctr âˆ— lock_inv sh h (cptr_lock_inv g1 g2 ctr) âˆ— ghost_frag (if left then g1 else g2) 1.

Definition thread_lock_inv sh1 sh h g1 g2 ctr ht left :=
  self_part sh ht âˆ— thread_lock_R sh1 sh h g1 g2 ctr left.

Definition thread_func_spec :=
 DECLARE _thread_func
  WITH y : val, x : share * Qp * lock_handle * lock_handle * gname * gname * globals, left : bool
  PRE [ tptr tvoid ]
         let '(sh1, sh, h, ht, g1, g2, gv) := x in
         PROP  (readable_share sh1; ptr_of ht = y)
         PARAMS (y) GLOBALS (gv)
         SEP   (field_at sh1 t_counter [StructField _lock] (ptr_of h) (gv _c);
                lock_inv sh h (cptr_lock_inv g1 g2 (gv _c));
                ghost_frag (if left then g1 else g2) 0;
                lock_inv sh ht (thread_lock_inv sh1 sh h g1 g2 (gv _c) ht left))
  POST [ tint ]
         PROP ()
         RETURN (Vint Int.zero)
         SEP ().

Definition compute2_spec :=
 DECLARE _compute2
  WITH gv: globals
  PRE [] PROP() PARAMS() GLOBALS(gv)
            SEP(library.mem_mgr gv;
                  data_at Ews t_counter (Vint (Int.repr 0), Vundef) (gv _c);
                  has_ext tt)
  POST [ tint ] PROP() RETURN (Vint (Int.repr 2)) 
                      SEP(library.mem_mgr gv; data_at_ Ews t_counter (gv _c); has_ext tt).

Definition main_spec :=
 DECLARE _main
  WITH gv : globals
  PRE  [] main_pre prog tt gv
  POST [ tint ] main_post prog gv.

Definition Gprog : funspecs := ltac:(with_library prog [acquire_spec; release_spec; makelock_spec; freelock_spec;
  spawn_spec; incr_spec; read_spec; thread_func_spec; main_spec]).

Instance ctr_inv_exclusive : forall g1 g2 p,
ExclusiveProp (cptr_lock_inv g1 g2 p).
Proof.
  unfold cptr_lock_inv, ExclusiveProp; intros.
  iIntros "((% & ? & ?) & (% & ? & ?))".
  rewrite !field_at_field_at_; iApply (field_at__conflict with "[$]"); auto.
  { simpl; lia. }
Qed.
#[local] Hint Resolve ctr_inv_exclusive : core.
Typeclasses Opaque cptr_lock_inv.

Instance thread_lock_R_exclusive : forall sh1 sh h g1 g2 ctr left,
ExclusiveProp (thread_lock_R sh1 sh h g1 g2 ctr left).
Proof.
  unfold thread_lock_inv, ExclusiveProp; intros.
  iSteps as " _ _ g1 _ _ g2".
  iDestruct (own_valid_2 with "g1 g2") as %[]%@excl_auth_frag_op_valid.
Qed.
#[local] Hint Resolve thread_lock_R_exclusive : core.

Lemma ghost_var_inj : forall g x y, ghost_auth g x âˆ— ghost_frag g y âŠ¢ âŒœx = yâŒ.
Proof.
  intros; iIntros "(a & f)".
  iDestruct (own_valid_2 with "a f") as %H%@excl_auth_agree; done.
Qed.

Lemma ghost_var_incr : forall g1 g2 x y n (left : bool), ghost_auth g1 x âˆ— ghost_auth g2 y âˆ— ghost_frag (if left then g1 else g2) n âŠ¢
  |==> âŒœ(if left then x else y) = nâŒ âˆ§ ghost_auth (if left then g1 else g2) (n+1)%nat âˆ— ghost_frag (if left then g1 else g2) (n+1)%nat âˆ—
       ghost_auth (if left then g2 else g1) (if left then y else x).
Proof.
  destruct left.
  - iIntros "(a & $ & f)".
    iDestruct (ghost_var_inj with "[$a $f]") as %->.
    iMod (own_update_2 with "a f") as "($ & $)"; last done.
    apply @excl_auth_update.
  - iIntros "($ & a & f)".
    iDestruct (ghost_var_inj with "[$a $f]") as %->.
    iMod (own_update_2 with "a f") as "($ & $)"; last done.
    apply @excl_auth_update.
Qed.


Global Instance unfold_cinv_hint g1 g2 _c (gv:globals):
HINT cptr_lock_inv g1 g2 (gv _c) âœ± [-; emp]
  âŠ« [id] vint_z; field_at Ews t_counter (DOT _ctr) vint_z (gv _c)
  âœ±[âˆƒ x y z: nat, <affine> âŒœz = (x + y)%nat âˆ§ (vint (Z.of_nat z)) = vint_zâŒ âˆ— ghost_auth g1 x âˆ— ghost_auth g2 y ].
Proof.
  unfold cptr_lock_inv. iSteps.
Qed.

Global Instance fold_cinv_hint z x y g1 g2 _c (gv:globals):
(z = x + y)%nat ->
HINT Îµâ‚€ âœ± [-; (field_at Ews t_counter (DOT _ctr) (Vint (Int.repr z)) (gv _c)) âˆ—
             ghost_auth g1 x âˆ— ghost_auth g2 y ]
  âŠ« [id]; cptr_lock_inv g1 g2 (gv _c) âœ± [ bi_emp ].
Proof.
  intros ->.
  unfold cptr_lock_inv. cbn. iStep. rewrite bi.sep_emp.
  iExists (x+y). iSteps. iExists x, y. iSteps.
Qed.

Global Instance ghost_auth_update g1 x n n':
    HINT (ghost_auth g1 x âˆ— ghost_frag g1 n) âœ± [-; emp] âŠ« [bupd]; (ghost_frag g1 (n')%nat) âœ± [ghost_auth g1 (n')%nat].
Proof.
  iStep as "a f". iDestruct (ghost_var_inj with "[$a $f]") as %->.
  iMod (own_update_2 with "a f") as "($ & $)"; last done.
  apply @excl_auth_update.
Qed.

(* for read *)
Global Instance close_cinv_g1_hint (x1 x2 y1 y2 z: nat) g1 g2 _c (gv:globals):
HINT field_at Ews t_counter (DOT _ctr) (Vint (Int.repr z)) (gv _c) âœ±
  [-; ghost_auth g1 x1 âˆ— ghost_frag g1 x2 âˆ— ghost_auth g2 y1 âˆ— ghost_frag g2 y2 âˆ— <affine> âŒœz >= y1âŒ]
  âŠ« [bupd]; cptr_lock_inv g1 g2 (gv _c) âœ± [âœ‹z>=y1ğŸ¤š âˆ— âœ‹x1=x2ğŸ¤š âˆ— âœ‹y1=y2ğŸ¤š âˆ— ghost_frag g1 (z - y1) âˆ— ghost_frag g2 y2].
Proof.
rewrite /_ProtectPure.
iStep as "ctr â—g1 â—¯g1 â—g2 â—¯g2 %". unfold cptr_lock_inv.
iDestruct (ghost_var_inj with "[$â—g1 $â—¯g1]") as %<-.
iDestruct (ghost_var_inj with "[$â—g2 $â—¯g2]") as %<-.
iAssert (|==>ghost_auth g1 (z-y1) âˆ— ghost_frag g1 (z-y1)) with "[â—g1 â—¯g1]" as "> [â—g1 â—¯g1]".
iMod (own_update_2 with "â—g1 â—¯g1") as "($ & $)"; last done.
apply @excl_auth_update.
iFrame. iSteps.
Qed.

Global Instance close_cinv_update_g1_hint (x y n z: nat) (left:bool) g1 g2 _c (gv:globals):
HINT field_at Ews t_counter (DOT _ctr) (Vint (Int.add (Int.repr (Z.of_nat z)) (Int.repr 1))) (gv _c) âœ±
  [-;  ghost_auth g1 x âˆ— ghost_auth g2 y âˆ— ghost_frag (if left then g1 else g2) n âˆ— <affine>âŒœ(x+y=z)%natâŒ ]
  âŠ« [bupd]; cptr_lock_inv g1 g2 (gv _c) âœ± [âœ‹n=(if left then x else y)ğŸ¤š âˆ— âœ‹x+y=zğŸ¤š âˆ— 
                                           ghost_frag (if left then g1 else g2) ((if left then x else y)+1)].
Proof.
rewrite /_ProtectPure.
iIntros. simpl.
iStep as "â—g1  â—g2 â—¯g ctr". unfold cptr_lock_inv.
destruct left.
- iDestruct (ghost_var_inj with "[$â—g1 $â—¯g]") as %<-.
  iAssert (|==>ghost_auth g1 (x+1) âˆ— ghost_frag g1 (x+1)) with "[â—g1 â—¯g]" as "> [â—g1 â—¯g]".
  iMod (own_update_2 with "â—g1 â—¯g") as "($ & $)"; last done.
  apply @excl_auth_update.
  rewrite add_repr. replace 1%Z with (Z.of_nat (Z.to_nat 1)) by lia. rewrite -Nat2Z.inj_add.
  iFrame. iSteps.
- iDestruct (ghost_var_inj with "[$â—g2 $â—¯g]") as %<-.
  iAssert (|==>ghost_auth g2 (y+1) âˆ— ghost_frag g2 (y+1)) with "[â—g2 â—¯g]" as "> [â—g2 â—¯g]".
  iMod (own_update_2 with "â—g2 â—¯g") as "($ & $)"; last done.
  apply @excl_auth_update.
  rewrite add_repr. replace 1%Z with (Z.of_nat (Z.to_nat 1)) by lia. rewrite -Nat2Z.inj_add.
  iFrame. iSteps.
Qed.


Ltac2 Set vstep_specs as old_vstep_specs :=
  fun _ => (constr:(_release), constr:(release_simple))::
           (constr:(_acquire), constr:(funspec_sub_refl_dep))::
           (old_vstep_specs ()).

Set Default Proof Mode "Ltac2".

Lemma body_incr: semax_body Vprog Gprog f_incr incr_spec.
Proof.
  vstep ().
  vstep ().
  vstep (). 
  vstep (). (** unfolds cptr_lock_inv, get _c._lockâ†¦_ *)
  vstep ().
  vstep ().
  vstep ().
  vstep ().  (** calls entailer!!, good at `PROP $ LOCAL $ SEP _ âŠ¢ ...` *)
  ltac1:(iSteps).
Qed.

Lemma body_read : semax_body Vprog Gprog f_read read_spec.
Proof.
  vsteps ().
  rewrite Nat.add_sub (* TODO add this to normalization/autorewrite library? *); vstep ().
Qed.

Ltac2 Set vstep_specs as old_vstep_specs :=
  fun _ => (constr:(_incr), constr:(funspec_sub_refl_dep))::
           (constr:(_release), constr:(release_self))::
           (old_vstep_specs ()).


(* Lemma body_thread_func : semax_body Vprog Gprog f_thread_func thread_func_spec.
Proof.
  vsteps ().
Qed. *)

(** Claim: biabduction in VST, more automation while not modifying floyd or diaframe 
           modularize/reorgan proof, pull proofs out of body_xxx, explicit about interactions with invariants
           only add simple automation (namely diaframe), does not make difficulty go away *)

Ltac2 Set vstep_specs as old_vstep_specs :=
  fun _ => 
           (constr:(_makelock), constr:(funspec_sub_refl_dep))::
           (constr:(_freelock), constr:(funspec_sub_refl_dep))::
           (constr:(_spawn), constr:(release_self))::
           (old_vstep_specs ()).


Global Instance ghost_split_hint g (n:nat):
  HINT own g (â—E n â‹… â—¯E n : excl_authR natO) âœ± [-; emp] âŠ« 
    [id]; own g (â—E n : excl_authR natO) âœ± [own g (â—¯E n : excl_authR natO)].
Proof.
  ltac1:(rewrite own_op; iSteps).
Qed.

Global Instance ghost_alloc_hint n:
  HINT Îµâ‚€ âœ± [-; emp] âŠ« [bupd] g; ghost_auth g n âœ± [ghost_frag g n].
Proof.
  intros.
  unfold ghost_auth, ghost_frag.
  ltac1:(iMod (own_alloc (â—E n â‹… â—¯E n : excl_authR natO)); [apply excl_auth_valid|iSteps]).
Qed.

  Context {LI : lock_impl}.

  Notation InvType := Mpred.
Set Default Proof Mode "Classic".
Program Definition release_spec_simple2 :=
    TYPE (ProdType (ConstType _) InvType)
    WITH sh : _, h : _, R : _
    PRE [ tptr t_lock ]
       PROP (ExclusiveProp R)
       PARAMS (ptr_of h)
       SEP (lock_inv sh h R; R)
    POST [ tvoid ]
       PROP ()
       LOCAL ()
       SEP (lock_inv sh h R).
  Next Obligation.
  Admitted.
  Next Obligation.
  Admitted.

  Lemma release_simple2 : funspec_sub lock_specs.release_spec release_spec_simple2.
  Proof.
    Admitted.

Ltac2 Set vstep_specs as old_vstep_specs :=
  fun _ => 
           (constr:(_release), constr:(release_simple2))::
           (old_vstep_specs ()).
  
  
(* Set Default Proof Mode "Ltac2". *)
Lemma body_main:  semax_body Vprog Gprog f_compute2 compute2_spec.
Proof.
  start_function. forward.



  Ltac2 print_syntax_kind (c:constr) :=
  printf "The constr %t has kind: " c;
  match Constr.Unsafe.kind c with
  | Constr.Unsafe.Constant _ _ => printf "Constant"
  | Constr.Unsafe.Var _ => printf "Var"
  | Constr.Unsafe.App _ _ => printf "App"
  | Constr.Unsafe.Lambda _ _ => printf "Lambda"
  | Constr.Unsafe.Prod _ _ => printf "Prod"
  | Constr.Unsafe.LetIn _ _ _ => printf "LetIn"
  | Constr.Unsafe.Cast _ _ _ => printf "Cast"
  | Constr.Unsafe.Evar _ _ => printf "Evar"
  | Constr.Unsafe.Case _ _ _ _ _ => printf "Case"
  | Constr.Unsafe.Fix _ _ _ _ => printf "Fix"
  | Constr.Unsafe.CoFix _ _ _ => printf "CoFix"
  | Constr.Unsafe.Proj _ _ _ => printf "Proj"
  | Constr.Unsafe.Array _ _ _ _ => printf "Array"
  | Constr.Unsafe.Float _  => printf "Float"
  | Constr.Unsafe.Uint63 _ => printf "Uint63"
  | Constr.Unsafe.Constructor _ _ => printf "Constructor"
  | Constr.Unsafe.Ind _ _ => printf "Ind"
  | Constr.Unsafe.Sort _ => printf "Sort"
  | Constr.Unsafe.Meta _ => printf "Meta"
  | Constr.Unsafe.Rel _ => printf "Rel"
  end.


  Ltac2 get_fpre_sep2 (sub:constr) :=
    lazy_match! (Constr.type sub) with
    |  funspec_sub _ ?sp_pre =>
    (* print_syntax_kind sp_pre; *)
    let sp := match (Constr.Unsafe.kind sp_pre) with
              | Constr.Unsafe.Constant sp_def _ => let sp_ref :=  Std.ConstRef sp_def in eval unfold $sp_ref in $sp_pre
              | _ => sp_pre
              end in
    lazy_match! sp with
    | (mk_funspec _ _ _ _ ?fpre _) =>
    (* apply semax_extract_affine_sep > [apply _|]; *)
    match! fpre with Î»ne _ : ?arg_type, _ =>
    let arg_type := eval cbn in $arg_type in
    let (arg_evar, evar_ids) := evar_tuple arg_type in
    let arg_evar_name := Fresh.in_goal @arg_evar in
    epose $arg_evar as $arg_evar_name;
    let fpre := constr:($fpre $arg_evar) in
    let fpre := eval cbn in $fpre in
    let fpre_sep_name := Fresh.in_goal @fpre_sep in
    lazy_match! fpre with | context [SEPx ?fpre_sep] =>
      pose $fpre_sep as $fpre_sep_name
    end;
    Std.subst evar_ids;
    clear sub;
    (fpre_sep_name, arg_evar_name)
    end end end
  .


  Ltac2 vstep_call2 () :=
ltac1:(vstep_call_preprocess);
let specs := match! goal with 
              | [ |- context [Scall _ (Evar ?ff _)  _]] => get_specs_for ff end
in
let rec try_specs sps :=
  match sps with
  | sp :: sps' => Control.plus (fun () => printf "In vstep_call: try applying spec %t" sp; 
                                          (* ltac1:(f_spec |- prove_call_setup1 f_spec) (Ltac1.of_constr sp); *)
                                            let (fpre_sep_name, arg_evar_name) := get_fpre_sep2 sp in
                                            printf "2";
                                            ltac1:(fpre_sep |- change_pre_sep_with fpre_sep) (Ltac1.of_constr (Control.hyp fpre_sep_name));
                                            (* have to pass body of arg_evar_name, otherwise forward_call sometimes fails to unfold it *)
                                            let arg_evar_body:constr := get_body_of_localdef arg_evar_name in
                                            ltac1:(spec args |- forward_call spec args) (Ltac1.of_constr sp) (Ltac1.of_constr arg_evar_body);
                                            clear fpre_sep_name, arg_evar_name; ())
                                (fun _ => printf "In vstep_call: applying %t failed" sp; try_specs sps') 
  | _ => () (* TODO explicitly fail here when all possible specs are tried? *)
  end 
in try_specs specs.


ltac2:(vstep ()).

Intros lock. (* FIXME this takes 3 seconds *)
  ltac2:(vstep ()).
  ltac2:(vstep ()).
  ltac2:(vstep ()).
(* ltac2:(get_fpre_sep2 constr:(release_simple2)). *)

eapply (semax_change_pre_for_forward_call _ _ _ _ _ fpre_sep0);
[
cbn;
iSteps;
(* into_fold_right_sepcons_Î“s;
repeat (Combine (fold_right_sepcon _) (fold_right_sepcon _));
iStopProof; rewrite -fupd_intro;
match goal with
    | |- emp âŠ¢ fold_right_sepcon _ => rewrite emp_fold_right_sepcon_nil
    | _ => idtac
end;    
f_equal *)
idtac
| simpl app].
  ltac2:(vstep_call2 ()).


  vstep ().
  vstep ().
  vstep ().
  ltac1:(Intros lock).
  vstep ().
  vstep ().


  (* FIXME don't have to actually prove call setup, just get the sep part? *)
  let sp := constr:(release_simple2) in
  ltac1:(f_spec |- prove_call_setup1 f_spec) (Ltac1.of_constr sp).
  let (fpre_sep_name, arg_evar_name) := get_fpre_sep () in ().
  
  vstep ().

  rename a into gv.
  set (ctr := gv _c).
  forward.
  ghost_alloc (fun g => own g (â—E O â‹… â—¯E O : excl_authR natO)).
  { apply excl_auth_valid. }
  Intro g1.
  ghost_alloc (fun g => own g (â—E O â‹… â—¯E O : excl_authR natO)).
  { apply excl_auth_valid. }
  Intro g2.
  sep_apply (library.create_mem_mgr gv).
  forward_call (gv, fun _ : lock_handle => cptr_lock_inv g1 g2 ctr).
  Intros lock.
  forward.
  forward.
  forward_call release_simple (1%Qp, lock, cptr_lock_inv g1 g2 ctr).
  { lock_props.
    rewrite !own_op /cptr_lock_inv /ghost_auth.
    Exists O O O.
    unfold_data_at (data_at _ _ _ _); entailer!. }
  (* need to split off shares for the locks here *)
  destruct split_Ews as (sh1 & sh2 & ? & ? & Hsh).
  forward_call (gv, fun lockt => thread_lock_inv sh2 (1/2)%Qp lock g1 g2 ctr lockt).
  Intros lockt.
  sep_apply lock_inv_isptr; Intros.
  forward_spawn _thread_func (ptr_of lockt) (sh2, (1/2)%Qp, lock, lockt, g1, g2, gv).
  { rewrite -{3}Qp.half_half -frac_op -lock_inv_share_join.
    rewrite -{1}Qp.half_half -frac_op -lock_inv_share_join.
    erewrite <- field_at_share_join; try apply Hsh; auto.
    subst ctr; entailer!. }
  { simpl; auto. }
  forward_call (sh1, (1/2)%Qp, lock, g1, g2, false, 0, gv).
  forward_call ((1/2)%Qp, lockt, thread_lock_inv sh2 (1/2)%Qp lock g1 g2 (gv _c) lockt).
  unfold thread_lock_inv at 2; unfold thread_lock_R; Intros.
  simpl.
  forward_call (sh1, (1/2)%Qp, lock, g1, g2, 1, 1, gv).
  (* We've proved that t is 2! *)
  forward.
  forward_call ((1/2)%Qp, lock, cptr_lock_inv g1 g2 (gv _c)).
  forward_call freelock_self ((1/2)%Qp, (1/2)%Qp, lockt, thread_lock_R sh2 (1/2) lock g1 g2 (gv _c)).
  { unfold thread_lock_inv, selflock; cancel. }
  { rewrite frac_op Qp.half_half //. }
  forward.
  forward_call freelock_simple (lock, cptr_lock_inv g1 g2 (gv _c)).
  { lock_props.
    rewrite -{2}Qp.half_half -frac_op -lock_inv_share_join.
    subst ctr; cancel. }
  forward.
Qed.

Lemma prog_correct:
  semax_prog prog tt Vprog Gprog.
Proof.
prove_semax_prog.
semax_func_cons_ext.
{ simpl.
  destruct x; simpl.
  monPred.unseal.
  Intros h.
  unfold PROPx, LOCALx, SEPx, local, lift1; simpl; unfold liftx; simpl; unfold lift.
  monPred.unseal; Intros.
  destruct ret; unfold eval_id in H0; simpl in H0; subst; simpl; [|contradiction].
  saturate_local; auto. }
semax_func_cons_ext.
semax_func_cons_ext.
semax_func_cons_ext.
semax_func_cons_ext.
semax_func_cons body_incr.
semax_func_cons body_read.
semax_func_cons body_thread_func.
semax_func_cons body_main.
Qed.

End mpred.
